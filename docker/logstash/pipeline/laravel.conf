input {
  file {
    path => "/var/log/laravel/laravel.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => multiline {
      pattern => "^\[\d{4}-\d{2}-\d{2}"
      negate => true
      what => "previous"
    }
  }
}

filter {
  # Parse Laravel log format
  grok {
    match => {
      "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] %{DATA:environment}\.%{DATA:level}: %{GREEDYDATA:message}"
    }
  }

  # Parse additional context (JSON)
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "context"
    }
  }

  # Add custom tags
  mutate {
    add_field => {
      "service" => "laravel-app"
      "application" => "web-ban-do-dien-tu"
    }
    add_tag => ["laravel"]
  }

  # Convert timestamp
  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  # Add severity
  if [level] == "ERROR" or [level] == "CRITICAL" or [level] == "ALERT" or [level] == "EMERGENCY" {
    mutate {
      add_field => { "severity" => "high" }
    }
  } else if [level] == "WARNING" or [level] == "NOTICE" {
    mutate {
      add_field => { "severity" => "medium" }
    }
  } else {
    mutate {
      add_field => { "severity" => "low" }
    }
  }

  # Parse circuit breaker logs
  if [message] =~ /Circuit breaker/ {
    mutate {
      add_tag => ["circuit-breaker"]
    }
    
    grok {
      match => {
        "message" => "Circuit breaker (?:for )?%{DATA:service_name}(?: moved to | is )%{WORD:circuit_state}"
      }
      tag_on_failure => []
    }
  }

  # Parse payment logs
  if [message] =~ /Payment|MoMo|VNPay|PayPal/ {
    mutate {
      add_tag => ["payment"]
    }
  }

  # Parse order logs
  if [message] =~ /Order|Transaction|Checkout/ {
    mutate {
      add_tag => ["order"]
    }
  }

  # Parse saga logs
  if [message] =~ /Saga/ {
    mutate {
      add_tag => ["saga"]
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "laravel-%{+YYYY.MM.dd}"
    document_type => "_doc"
  }

  # Debug output (optional, remove in production)
  stdout {
    codec => rubydebug
  }
}
